# Aliases

if [ $SHELL = "/bin/zsh" ]
then
  echo "On ZSH, using alias -g"
  alias -g aliasG='alias -g '
else
  echo "Not on ZSH, using alias"
  alias aliasG='alias '
fi

aliasG sudo='sudo '

alias SC="source $ZDOTDIR/.zshrc"

aliasG fastping='ping -c 100 -s 2 '

alias C="clear"
alias dfh='df -h'
alias freeh='free -mh'
alias EE='exit'
aliasG chx="chmod +x "
aliasG chrx="chmod -R +x "
aliasG G='| grep -i '
aliasG L='| less +f '
aliasG dush='sudo du -sh '
aliasG egrep='egrep --color=auto '
aliasG fgrep='fgrep --color=auto '
aliasG grep='grep --color=auto '
alias h="history -10" # last 10 history commands
aliasG hg="history | grep " # +command
aliasG nta='sudo netstat -poeta '
aliasG psa='sudo ps -aux '

if command -v ssh-add &> /dev/null
then
  sshadd ()
  {
    eval $(ssh-agent)
    for i in $(/bin/ls ~/.ssh/id_* | grep -v pub)
    do
      ssh-add $i
    done
  }
fi

if command -v ss &> /dev/null
then
  aliasG ssa='sudo ss -poeta '
fi

if command -v notify-send &> /dev/null
  then
  # Credits to: https://gist.github.com/Feniksovich
  # Add an "alert" alias for long running commands.  Use like so:
  #   sleep 10; alert
  alias alert='notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history|tail -n1|sed -e '\''s/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//'\'')"'
fi

if command -v systemctl &> /dev/null
then
  #Basic systemctl commands
  aliasG systemctl="sudo systemctl "
  aliasG ctl="systemctl "
  # Credits to: https://gist.github.com/Feniksovich
  aliasG ctlsp="systemctl stop "
  aliasG ctlst="systemctl start "
  aliasG ctlrt="systemctl restart "
  aliasG ctlrl="systemctl reload "
  aliasG ctls="systemctl status "

  # Enable/Disable commands for units
  aliasG ctle='systemctl enable '
  aliasG ctld='systemctl disable '

  # Start and then view status of service
  ctlsts ()
  {
    systemctl start "$1"
    systemctl status "$1"
  }

  # Restart and then view status of service
  ctlrts ()
  {
    systemctl restart "$1"
    systemctl status "$1"
  }

  # Masking Units to disabling them
  aliasG ctlmask='systemctl mask '
  aliasG ctlunmask='systemctl unmask '

  # List failed units and reset systemd system status
  aliasG ctlfailed='systemctl --failed --all '
  aliasG ctlrf='systemctl reset-failed '

  aliasG ctldrd="systemctl daemon-reload "
fi

if command -v iptables &> /dev/null
then
  aliasG it='iptables '
  # Lookup iptables chain
  aliasG itlookup="iptables --line-numbers -nvL "
fi

if command -v apt &> /dev/null
then
  aliasG j="journalctl "
  aliasG jf="journalctl --follow "
  aliasG ju="journalctl -xeu "
  aliasG juf="journalctl -feu "
fi

if command -v apt &> /dev/null
then
    aliasG apt='sudo apt '
    aliasG apts='sudo apt search '
    aliasG aptu='sudo apt update '
    aliasG aptup='sudo apt upgrade -y '
    aliasG aptdup='sudo apt dist-upgrade -y '
    aliasG apti='sudo apt install -y '
    aliasG aptr='sudo apt remove '
    aliasG aptar='sudo apt autoremove '
    aliasG aptap='sudo apt autopurge '
fi

if command -v dnf &> /dev/null
then
    aliasG dnf='sudo dnf '
    aliasG dnfs='sudo dnf search '
    aliasG dnfq='sudo dnf repoquery '
    aliasG dnfu='sudo dnf check-update '
    aliasG dnfup='sudo dnf upgrade -y '
    aliasG dnfds='sudo dnf distro-sync -y '
    aliasG dnfi='sudo dnf install -y '
    aliasG dnfr='sudo dnf remove '
    aliasG dnfar='sudo dnf autoremove '
    aliasG dnfc='sudo dnf copr '
fi

if command -v fwupdmgr &>/dev/null
then
  fwcheck ()
  {
    sudo fwupdmgr refresh --force
    sudo fwupdmgr get-updates
    sudo fwupdmgr get-updates
  }
fi

if command -v tmux &> /dev/null
then
    aliasG T='tmux '
    aliasG tls='tmux ls '
    aliasG ta='tmux attach -t '
    aliasG tn='tmux new -s '
    aliasG tr='tmux rename-session -t '
    aliasG tk='tmux kill-session -t '
fi

if command -v nvim &> /dev/null ; then
  aliasG e='nvim '
  aliasG nv='nvim '
  aliasG vi='nvim '
  aliasG vim='nvim '
  aliasG E='| nvim '
  if command -v nvr &> /dev/null
  then
    aliasG nvimr='nvim --listen /tmp/nvimsocket '
    aliasG nvrs='nvr -s '
  fi
fi

if command -v xclip &> /dev/null
then
  aliasG Xp='xclip -o '
  aliasG Xy=' | xclip -i '
fi
if command -v clipboard &> /dev/null
then
  aliasG Cp="clipboard "
  aliasG Cy=' | clipboard '
fi
if command -v wl-copy &> /dev/null
then
  aliasG Wp="wl-paste "
  aliasG Wy=' | wl-copy '
fi

if command -v ranger &> /dev/null
then
  aliasG rw='ranger '
fi

if command -v fdfind &> /dev/null
then
  aliasG fd='fdfind '
fi

if command -v zoxide &> /dev/null ; then
  # aliasG cd='z '
fi

if command -v exa &> /dev/null
then
  aliasG ola='/bin/ls -lahi --color=auto '
  aliasG ols='/bin/ls --color=auto '
  aliasG ls="exa --icons --git --group-directories-first "
  aliasG ll="exa -lg --icons --git --group-directories-first "
  aliasG la="exa -aglm --icons --git --group-directories-first "
  aliasG lt="exa -L 2 --icons --tree --git-ignore --group-directories-first "
fi

if command -v git &> /dev/null
then
  aliasG g='git '
  function dotfiles {
    git --git-dir=$HOME/.dotfiles_git/ --work-tree=$HOME $@
  }    
  aliasG dot='dotfiles '
fi

installKubectl ()
{
  curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
  curl -LO "https://dl.k8s.io/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256"
  echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check
  if [[ $? == 0 ]]
  then
    chmod +x kubectl
    mkdir -p ~/.local/bin
    mv ./kubectl ~/.local/bin/kubectl
  fi
}
if command -v kubectl &> /dev/null
then
    source <(kubectl completion zsh)
    alias k='kubectl '
fi

if command -v minikube &> /dev/null
then
    source <(minikube completion zsh)
    alias mk='minikube '
fi

if command -v docker &> /dev/null
then
    aliasG dk='docker '
fi

if command -v ansible &> /dev/null
then
    aliasG a='ansible '
    aliasG ap='ansible-playbook '
    aliasG ag='ansible-galaxy '
fi

if command -v podman &> /dev/null
then
    aliasG pd='podman '
fi

aliasG xway='env -u WAYLAND_DISPLAY '

if command -v curl &> /dev/null
then
  # Creditst to Jeremy "Jay" LaCroix
  # <https://www.learnlinux.tv/10-linux-terminal-tips-and-tricks-to-enhance-your-workflow/
  c() {
    # Ask cheat.sh website for details about a Linux command.
    curl -m 10 "http://cheat.sh/${1}" 2>/dev/null || printf '%s\n' "[ERROR] Something broke"
  }
  alias speedtest='curl -s https://raw.githubusercontent.com/sivel/speedtest-cli/master/speedtest.py | python -'
  wth() {
    curl -m 10 "https://wttr.in/${1}" 2>/dev/null || printf '%s\n' "[ERROR] Something broke"
  }
  # alias myip='curl http://ipecho.net/plain; echo '
  alias myip='curl icanhazip.com'
  # alias wimp='curl https://wttr.in/imperia'
  alias wimp='wth imperia'
fi

checkSum () {
  if [ $1 = "" ] || [ $2 = "" ] || [ $3 = "" ]
  then
    echo "Usage: checkmd5 [md5|sha1|sha256|sha512] [file] [sum]"
    return 2
  fi
  if [ $1 != "md5" ] && [ $1 != "sha1" ] && [ $1 != "sha256" ] && [ $1 != "sha512" ]
  then
    echo "algorithm (firt paramater) must be [md5|sha1|sha256|sha512]"
    return 3
  fi
  local command="${1}sum"
  if command -v $command &> /dev/null 
  then
    local sum=$($command $2 | cut -d ' ' -f 1)
    echo "Given: $3"
    echo "Calculated: $sum"
    if [ $sum = $3 ]
    then
      echo "${command} OK"
      return 0
    else
      echo "${command} NOT OK!!"
      return 1
    fi
  echo "Command ${command} is not installed."
  return 4
  fi
}

getCharge ()
{
  local mode=$(sudo cat /sys/bus/platform/drivers/ideapad_acpi/VPC2004:00/conservation_mode)
  echo "Conservation mode: ${mode}"
}
stopCharge ()
{
  echo 1 | sudo tee /sys/bus/platform/drivers/ideapad_acpi/VPC2004:00/conservation_mode
}
startCharge ()
{
  echo 0 | sudo tee /sys/bus/platform/drivers/ideapad_acpi/VPC2004:00/conservation_mode
}

# Credits to Connor - https://stackoverflow.com/questions/24283097/reusing-output-from-last-command-in-bash
# Usage
# $ find . -name 'filename' | cap
# /path/to/filename
#
# $ ret
# /path/to/filename
# capture the output of a command so it can be retrieved with ret
cap () { tee /tmp/capture.out; }

# return the output of the most recent command that was captured by cap
ret () { cat /tmp/capture.out; }

if [ $( command -v fzf ) ] && [ $( command -v rg ) ] && [ $( command -v bat ) ] ; then
  export FZF_BASE=/usr/bin/fzf
  export FZF_DEFAULT_COMMAND='rg --ignore-case --files --no-ignore-vcs --hidden '
  # catppucin theme
  # export FZF_DEFAULT_OPTS=' \
    # --preview bat --border=rounded  \
    # --color=bg+:#313244,bg:#1e1e2e,spinner:#f5e0dc,hl:#f38ba8 \
    # --color=fg:#cdd6f4,header:#f38ba8,info:#cba6f7,pointer:#f5e0dc \
    # --color=marker:#f5e0dc,fg+:#cdd6f4,prompt:#cba6f7,hl+:#f38ba8"'
  # aliasG fzfb="fzf \
    # --preview bat --border=rounded  \
    # --color=bg+:#313244,bg:#1e1e2e,spinner:#f5e0dc,hl:#f38ba8 \
    # --color=fg:#cdd6f4,header:#f38ba8,info:#cba6f7,pointer:#f5e0dc \
    # --color=marker:#f5e0dc,fg+:#cdd6f4,prompt:#cba6f7,hl+:#f38ba8 \
    # ; "
  # dracula theme
  export FZF_DEFAULT_OPTS="\
    --preview bat --border=rounded  \
    --color=fg:#f8f8f2,bg:#282a36,hl:#bd93f9 \
    --color=fg+:#f8f8f2,bg+:#44475a,hl+:#bd93f9 \
    --color=info:#ffb86c,prompt:#50fa7b,pointer:#ff79c6 \
    --color=marker:#ff79c6,spinner:#ffb86c,header:#6272a4 \
    ;"
  DISABLE_FZF_AUTO_COMPLETION="false"
  DISABLE_FZF_KEY_BINDINGS="true"
  aliasG fzfb="fzf \
    # --preview bat --color=always --style=numbers --line-range=:500 {} \
    --preview bat --border=rounded  \
    --color=fg:#f8f8f2,bg:#282a36,hl:#bd93f9 \
    --color=fg+:#f8f8f2,bg+:#44475a,hl+:#bd93f9 \
    --color=info:#ffb86c,prompt:#50fa7b,pointer:#ff79c6 \
    --color=marker:#ff79c6,spinner:#ffb86c,header:#6272a4 \
    ;"
  aliasG R='| rg '
else
  echo "fzf|rg|bat missing..."
fi
