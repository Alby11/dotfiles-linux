# vim: filetype=zsh

#
# .zsh_plugins.post - post-antidote plugins file
#

ECHOCAT '.zsh_plugins.post - post-antidote plugins file'

antidote_list="$(antidote list)"

string="ohmyzsh/ohmyzsh"
if [[ $antidote_list =~ $string ]]; then
  export ZSH=$(antidote path ohmyzsh/ohmyzsh)
  # space expands all aliases, including global
  bindkey          "^ " globalias
  bindkey -M emacs "^ " globalias
  bindkey -M viins "^ " globalias
  # control-space to make a normal space
  bindkey          " " magic-space
  bindkey -M emacs " " magic-space
  bindkey -M viins " " magic-space
  # normal space during searches
  bindkey -M isearch -r " "
  bindkey -M isearch "^ " magic-space
fi

string="zdharma-continuum/fast-syntax-highlighting"
if [[ $antidote_list =~ $string ]]; then
  local fast_theme="$(antidote path zdharma-continuum/fast-syntax-highlighting)"
  fast_theme="$fast_theme/fast-syntax-highlighting.plugin.zsh"
  [[ -f "$fast_theme" ]] && \
    source "$fast_theme" && \
    fast-theme XDG:catppuccin-mocha > /dev/null 2>&1

  chroma_single_word() {
    (( next_word = 2 | 8192 ))

    local __first_call="$1" __wrd="$2" __start_pos="$3" __end_pos="$4"
    local __style

    (( __first_call )) && { __style=${FAST_THEME_NAME}alias }
    [[ -n "$__style" ]] && (( __start=__start_pos-${#PREBUFFER}, __end=__end_pos-${#PREBUFFER}, __start >= 0 )) && reply+=("$__start $__end ${FAST_HIGHLIGHT_STYLES[$__style]}")

    (( this_word = next_word ))
    _start_pos=$_end_pos

    return 0
  }

  register_single_word_chroma() {
    local word=$1
    if [[ -x $(command -v $word) ]] || [[ -n $FAST_HIGHLIGHT["chroma-$word"] ]]; then
      return 1
    fi

    FAST_HIGHLIGHT+=( "chroma-$word" chroma_single_word )
    return 0
  }
  if command -v abbr &>/dev/null; then
    if [[ -n $FAST_HIGHLIGHT ]]; then
      for abbr in ${(f)"$(abbr list-abbreviations)"}; do
        if [[ $abbr != *' '* ]]; then
          register_single_word_chroma ${(Q)abbr}
        fi
      done
    fi
  fi
fi

string="unixorn/fzf-zsh-plugin"
if [[ $antidote_list =~ $string ]]; then
  export LESSOPEN='| lessfilter-fzf %s'
else
  ECHOCAT "LESSOPEN: lessfilter-fzf in not installed or in PATH
  leaving - $(echo $LESSOPEN) - instead" -i
fi

string="Aloxaf/fzf-tab"
if [[ $antidote_list =~ $string ]]; then
  autoload -Uz enable-fzf-tab
fi

string="mattmc3/zfunctions"
if [[ $antidote_list =~ $string ]]; then
  (( $+functions[funcsave] )) && echo "zfunctions loaded" || echo "zfunctions not loaded"
fi

string="lincheney/fzf-tab-completion"
if [[ $antidote_list =~ $string ]]; then
  # alias -g grep='/bin/grep'
  # SOURCE_RCFILE "$(antidote path lincheney/fzf-tab-completion)/$theShell/\
  #   fzf-$theShell-completion.sh" \
  #   ;
  # bindkey '^I' fzf_completion
  # zstyle ':completion:*' fzf-search-display true
fi

string="zsh-users/zsh-autosuggestions"
if [[ $antidote_list =~ $string ]]; then
  bindkey '^J' autosuggest-accept # ctrl-l, hjk
fi

string="MichaelAquilina/zsh-you-should-use"
if [[ $antidote_list =~ $string ]]; then
  export YSU_MESSAGE_POSITION="after"
  export YSU_MODE=ALL
fi

string="marlonrichert/zsh-autocomplete"
if [[ $antidote_list =~ $string ]]; then
  #Make Tab and ShiftTab cycle completions on the command line
  # bindkey '\t' menu-complete "$terminfo[kcbt]" reverse-menu-complete
  #Make Tab go straight to the menu and cycle there
  # bindkey '\t' menu-select "$terminfo[kcbt]" menu-select
  # bindkey -M menuselect '\t' menu-complete "$terminfo[kcbt]" reverse-menu-complete
  #make any completion widget first insert the longest sequence of characters that
  #will complete to all completions shown, if any, before inserting actual completions:
  # all Tab widgets
  zstyle ':autocomplete:*complete*:*' insert-unambiguous yes

  # all history widgets
  zstyle ':autocomplete:*history*:*' insert-unambiguous yes

  # ^S
  zstyle ':autocomplete:menu-search:*' insert-unambiguous yes
  #When using the above, if you want each widget to first try to insert only the
  #longest prefix that will complete to all completions shown, if any, then add the following:
  zstyle ':completion:*:*' matcher-list 'm:{[:lower:]-}={[:upper:]_}' '+r:|[.]=**'
  #Add or don't add a space after certain completions
  zstyle ':autocomplete:*' add-space \
    executables aliases functions builtins reserved-words commands
fi

string="jeffreytse/zsh-vi-mode"
if [[ $antidote_list =~ $string ]]; then
  # vi mode
  # export VI_MODE_RESET_PROMPT_ON_MODE_CHANGE=true
  # export VI_MODE_SET_CURSOR=true
  # export MODE_INDICATOR="%F{white}+%f"
  # export INSERT_MODE_INDICATOR="%F{yellow}+%f"
  ### Zsh Vi Mode - https://github.com/jeffreytse/zsh-vi-mode
  # Only changing the escape key to `jk` in insert mode, we still
  # keep using the default keybindings `^[` in other modes
  export ZVM_VI_ESCAPE_BINDKEY=kj
  # Change to Zsh's default readkey engine
  export ZVM_READKEY_ENGINE=$ZVM_READKEY_ENGINE_NEX # Better, beta
fi

string="Aloxaf/fzf-tab" 
if [[ $antidote_list =~ $string ]]; then
  # disable sort when completing `git checkout`
  # zstyle ':completion:*:git-checkout:*' sort false
  # set descriptions format to enable group support
  # zstyle ':completion:*:descriptions' format '[%d]'
  # switch group using `,` and `.`
  # zstyle ':fzf-tab:*' switch-group ',' '.'
  # set list-colors to enable filename colorizing
  # zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
  # preview directory's content with eza when completing cd
fi

string="zsh-users/zsh-autosuggestions"
if [[ $antidote_list =~ $string ]]; then
  ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=245'
  ZSH_AUTOSUGGEST_CLEAR_WIDGETS+=(
      "expand-or-complete"
      "pcomplete"
      "copy-earlier-word"
  )
fi

string="zsh-users/zsh-history-substring-search"
if [[ $antidote_list =~ $string ]]; then
  bindkey '^[[A' history-substring-search-up
  bindkey '^[[B' history-substring-search-down
  bindkey -M emacs '^P' history-substring-search-up
  bindkey -M emacs '^N' history-substring-search-down
  bindkey -M vicmd 'k' history-substring-search-up
  bindkey -M vicmd 'j' history-substring-search-down
fi

string="MichaelAquilina/zsh-you-should-use"
if [[ $antidote_list =~ $string ]]; then
  export YSU_MESSAGE_POSITION="after"
  export YSU_MODE=ALL
fi

string="MichaelAquilina/zsh-you-should-use"
if [[ $antidote_list =~ $string ]]; then
  export zs_set_path=1
fi

string="ohmyzsh/ohmyzsh"
if [[ $antidote_list =~ $string ]]; then
  # magic enter
  export MAGIC_ENTER_GIT_COMMAND='git status -u .'
  # MAGIC_ENTER_OTHER_COMMAND='ls -lh .'
  if command -v eza &>/dev/null; then
    export MAGIC_ENTER_OTHER_COMMAND="eza -aglm --icons --group-directories-first"
  else
    export MAGIC_ENTER_OTHER_COMMAND='ls -lAh --color=always'
  fi
  # per-directory-history
  [[ -z $HISTORY_BASE ]] && export HISTORY_BASE="$ZDOTDIR/.directory_history"
  [[ -z $HISTORY_START_WITH_GLOBAL ]] && export HISTORY_START_WITH_GLOBAL=false
  [[ -z $PER_DIRECTORY_HISTORY_TOGGLE ]] && export PER_DIRECTORY_HISTORY_TOGGLE='^G'
  # autoenv
  if [ ! -f /usr/local/lib/node_modules/@hyperupcall/autoenv/activate.sh ]; then
    # sudo npm install -g '@hyperupcall/autoenv'
  fi
fi

unset antidote_list string
