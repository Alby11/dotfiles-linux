# vim: filetype=zsh

# Set the name of the static .zsh plugins file antidote will generate.
zsh_plugins=${ZDOTDIR:-~}/.zsh_plugins.zsh

# Install antidote if missing
if ! [[ -d ${ZDOTDIR:-~}/.antidote ]]; then
  git clone --depth=1 https://github.com/mattmc3/antidote.git ${ZDOTDIR:-~}/.antidote
fi

# Ensure you have a .zsh_plugins.txt file where you can add plugins.
[[ -f ${zsh_plugins:r}.txt ]] || touch ${zsh_plugins:r}.txt

# Lazy-load antidote.
fpath+=(${ZDOTDIR:-~}/.antidote)
autoload -Uz $fpath[-1]/antidote

# Antidote settings
zstyle ':antidote:bundle' use-friendly-names 'yes'
emulate -L zsh
setopt extendedglob

# Generate static file in a subshell when .zsh_plugins.txt is updated.
if [[ ! $zsh_plugins -nt ${zsh_plugins:r}.txt ]]; then
  (antidote bundle <${zsh_plugins:r}.txt >|$zsh_plugins)
fi

# jeffreytse/zsh-vi-mode
function zvm_config() {
  ZVM_LINE_INIT_MODE=$ZVM_MODE_INSERT
  # Only changing the escape key to `jk` in insert mode, we still
  # keep using the default keybindings `^[` in other modes
  export ZVM_VI_ESCAPE_BINDKEY=kj
  # Change to Zsh's default readkey engine
  export ZVM_READKEY_ENGINE=$ZVM_READKEY_ENGINE_NEX # Better, beta
}

# Source your static plugins file.
source $zsh_plugins

# Set oh-my-zsh path according to antidote installation
export ZSH=$(antidote path ohmyzsh/ohmyzsh)
export ZSH_CUSTOM=$ZSH

#################################################################################
### Plugins settings
#################################################################################

### ohmysh/ohmyzsh
# dotenv
ZSH_DOTENV_PROMPT=false
# globalias
# control-space to make a normal space
bindkey            " " magic-space
bindkey -M emacs   " " magic-space
bindkey -M viins   " " magic-space
bindkey            "^@" magic-space
bindkey -M emacs   "^@" magic-space
bindkey -M viins   "^@" magic-space
if antidote path 'olets/zsh-abbr' > /dev/null; then
  # zsh-abbr
  # space expands all aliases, including global
  export ABBR_DEFAULT_BINDINGS=0
  # enter will expand and accept
  bindkey            "^M" abbr-expand-and-accept
  bindkey -M emacs   "^M" abbr-expand-and-accept
  bindkey -M viins   "^M" abbr-expand-and-accept
  # ctrl-space will expand and intput a space
  bindkey            "^ " abbr-expand
  bindkey -M emacs   "^ " abbr-expand
  bindkey -M viins   "^ " abbr-expand
  bindkey -M isearch "^ " abbr-expand
  bindkey            "^@" abbr-expand
  bindkey -M emacs   "^@" abbr-expand
  bindkey -M viins   "^@" abbr-expand
  bindkey -M isearch "^@" abbr-expand
fi
# bindkey          "^ " globalias
# bindkey -M emacs "^ " globalias
# bindkey -M viins "^ " globalias
# bindkey          "^@" globalias
# bindkey -M emacs "^@" globalias
# bindkey -M viins "^@" globalias
# magic enter
export MAGIC_ENTER_GIT_COMMAND='git status -u .'
# MAGIC_ENTER_OTHER_COMMAND='ls -lh .'
if command -v eza &>/dev/null; then
  export MAGIC_ENTER_OTHER_COMMAND="eza -aglm --icons --group-directories-first"
else
  export MAGIC_ENTER_OTHER_COMMAND='ls -lAh --color=always'
fi
# per-directory-history
[[ -z $HISTORY_BASE ]] && export HISTORY_BASE="$ZDOTDIR/.directory_history"
[[ -z $HISTORY_START_WITH_GLOBAL ]] && export HISTORY_START_WITH_GLOBAL=false
[[ -z $PER_DIRECTORY_HISTORY_TOGGLE ]] && export PER_DIRECTORY_HISTORY_TOGGLE='^G'
# autoenv
if [ ! -f /usr/local/lib/node_modules/@hyperupcall/autoenv/activate.sh ]; then
  # sudo npm install -g '@hyperupcall/autoenv'
fi

#alias-finder
zstyle ':omz:plugins:alias-finder' autoload yes # disabled by default
zstyle ':omz:plugins:alias-finder' longer yes # disabled by default
zstyle ':omz:plugins:alias-finder' exact yes # disabled by default
zstyle ':omz:plugins:alias-finder' cheaper yes # disabled by default

# fast-syntax-highlighting
local fast_theme="$(antidote path zdharma-continuum/fast-syntax-highlighting)"
fast_theme="$fast_theme/fast-syntax-highlighting.plugin.zsh"
[[ -f "$fast_theme" ]] && \
  source "$fast_theme" && \
  fast-theme --quiet XDG:catppuccin-mocha

chroma_single_word() {
  (( next_word = 2 | 8192 ))

  local __first_call="$1" __wrd="$2" __start_pos="$3" __end_pos="$4"
  local __style

  (( __first_call )) && { __style=${fast_theme_name}alias }
  [[ -n "$__style" ]] && (( __start=__start_pos-${#prebuffer}, __end=__end_pos-${#prebuffer}, __start >= 0 )) && reply+=("$__start $__end ${fast_highlight_styles[$__style]}")

  (( this_word = next_word ))
  _start_pos=$_end_pos

  return 0
}

register_single_word_chroma() {
  local word=$1
  if [[ -x $(command -v $word) ]] || [[ -n $fast_highlight["chroma-$word"] ]]; then
    return 1
  fi

  fast_highlight+=( "chroma-$word" chroma_single_word )
  return 0
}
if command -v abbr &>/dev/null; then
  if [[ -n $fast_highlight ]]; then
    for abbr in ${(f)"$(abbr list-abbreviations)"}; do
      if [[ $abbr != *' '* ]]; then
        register_single_word_chroma ${(q)abbr}
      fi
    done
  fi
fi

# unixorn/fzf-zsh-plugin
export LESSOPEN='| lessfilter-fzf %s'

# aloxaf/fzf-tab
autoload -Uz enable-fzf-tab
# disable sort when completing `git checkout`
zstyle ':completion:*:git-checkout:*' sort false
# set descriptions format to enable group support
# NOTE: don't use escape sequences here, fzf-tab will ignore them
zstyle ':completion:*:descriptions' format '[%d]'
# set list-colors to enable filename colorizing
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
# force zsh not to show completion menu, which allows fzf-tab to capture the unambiguous prefix
zstyle ':completion:*' menu no
# preview directory's content with eza when completing cd
zstyle ':fzf-tab:complete:cd:*' fzf-preview 'eza -1 --color=always $realpath'
# switch group using `<` and `>`
zstyle ':fzf-tab:*' switch-group '<' '>'
# to make full use of it's "popup" feature
zstyle ':fzf-tab:*' fzf-command ftb-tmux-popup

# MichaelAquilina/zsh-you-should-use
export YSU_MESSAGE_POSITION="after"
export YSU_MODE=ALL
export zs_set_path=1

# jeffreytse/zsh-vi-mode
# Only changing the escape key to `jk` in insert mode, we still
# keep using the default keybindings `^[` in other modes
# export ZVM_VI_ESCAPE_BINDKEY=kj
# Change to Zsh's default readkey engine
# export ZVM_READKEY_ENGINE=$ZVM_READKEY_ENGINE_NEX # Better, beta

# zsh-users/zsh-autosuggestions
ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=245'
ZSH_AUTOSUGGEST_CLEAR_WIDGETS+=(
  "expand-or-complete"
  "pcomplete"
  "copy-earlier-word"
)

# zsh-users/zsh-history-substring-search
# bindkey '^[[A' history-substring-search-up
# bindkey '^[[B' history-substring-search-down
bindkey -M emacs '^P' history-substring-search-up
bindkey -M emacs '^N' history-substring-search-down
bindkey -M viins '^P' history-substring-search-up
bindkey -M viins '^N' history-substring-search-down
bindkey -M vicmd 'k' history-substring-search-up
bindkey -M vicmd 'j' history-substring-search-down

# tom-doerr/zsh_codex
# Step 1: Capture the original function definition
original_function=$(typeset -f create_completion)
# Step 2: Modify the function definition
modified_function=$(echo "$original_function" \
  | sed 's@completion=$(echo -n "$text" | $ZSH_CUSTOM/plugins/zsh_codex/create_completion.py $CURSOR)@completion=$(echo -n "$text" | $(antidote path tom-doerr/zsh_codex)/create_completion.py $CURSOR)@g')
# Step 3: Redefine the function with the modified definition
eval "$modified_function"
zle -N create_completion
# Bind the create_completion function to a key.
bindkey '^Xo' create_completion
bindkey -M emacs '^Xo' create_completion
bindkey -M viins '^Xo' create_completion
